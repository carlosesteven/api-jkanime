'use strict';

const _ = require('lodash');
const cheerio = require('cheerio');
const ky = require('ky');
const qs = require('qs');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const ___default = /*#__PURE__*/_interopDefaultCompat(_);
const cheerio__default = /*#__PURE__*/_interopDefaultCompat(cheerio);
const ky__default = /*#__PURE__*/_interopDefaultCompat(ky);
const qs__default = /*#__PURE__*/_interopDefaultCompat(qs);

class CustomHTTPError extends Error {
}
async function makeRequest(url, responseType = "json", options = {}) {
  try {
    const response = await ky__default(url, options);
    if (!response.ok)
      throw new CustomHTTPError(`Fetch error: ${response.statusText}`);
    return await response[`${responseType}`]();
  } catch (error) {
    throw new Error(`Error making request to ${url}: ${error}`);
  }
}

const config = {
  baseURL: "https://jkanime.net/",
  remoteServerURL: "https://c4.jkdesu.com"
};

function extractPosterURL($element) {
  const style = $element.attr("style");
  if (style) {
    const matches = style.match(/url\((['"]?)(.*?)\1\)/);
    if (matches && matches[2])
      return matches[2];
  }
  return "";
}
function extractAnimeInfo$1($) {
  const animeItems = $(".row .anime__item");
  const animeInfoList = [];
  animeItems.each((index, element) => {
    const animeInfo = {
      slug: ___default.split($(element).find("a").attr("href"), "/").filter(Boolean).pop() ?? null,
      title: $(element).find("a").text().trim(),
      thumbnail: extractPosterURL($(element).find(".anime__item__pic")),
      type: $(element).find(".anime__item__text .anime").text().trim() ?? null,
      status: $(element).find(".anime__item__text ul li:nth(0)").text().trim() ?? null
    };
    animeInfoList.push(animeInfo);
  });
  return animeInfoList;
}
function extractNextPageLink$1($) {
  const nextPageLink = $(".text.nav-next").attr("href");
  return nextPageLink ?? null;
}
async function requestAnimeInfoByAlphabet(letter) {
  const allAnimeInfo = [];
  let nextPageLink = `${config.baseURL}letra/${letter}`;
  while (nextPageLink) {
    try {
      const response = await makeRequest(nextPageLink, "text", { method: "get" });
      if (!response)
        return null;
      const $ = cheerio__default.load(response);
      allAnimeInfo.push(...extractAnimeInfo$1($));
      nextPageLink = extractNextPageLink$1($);
    } catch (error) {
      console.error("Error fetching data:", error);
      break;
    }
  }
  return allAnimeInfo;
}
async function byAlphabet(letter) {
  return await requestAnimeInfoByAlphabet(letter);
}

const GENRE_MAP = [
  "accion",
  "aventura",
  "autos",
  "comedia",
  "dementia",
  "demonios",
  "misterio",
  "drama",
  "ecchi",
  "fantasia",
  "juegos",
  "hentai",
  "historico",
  "terror",
  "magia",
  "artes-marciales",
  "mecha",
  "musica",
  "parodia",
  "samurai",
  "romance",
  "colegial",
  "sci-fi",
  "shoujo-ai",
  "shounen-ai",
  "space",
  "deportes",
  "super-poderes",
  "vampiros",
  "yaoi",
  "yuri",
  "harem",
  "cosas-de-la-vida",
  "sobrenatural",
  "militar",
  "policial",
  "psicologico",
  "thriller",
  "espaol-latino",
  "isekai"
];
const DEMOGRAPHY_MAP = [
  "nios",
  "shoujo",
  "shounen",
  "seinen",
  "josei"
];
const CATEGORY_MAP = ["donghua"];
const TYPES_MAP = [
  "animes",
  "peliculas",
  "especiales",
  "ovas",
  "onas"
];
const STATE_MAP = [
  "emision",
  "finalizados",
  "estrenos"
];
const YEAR_MAP = [
  "2024",
  "2023",
  "2022",
  "2021",
  "2020",
  "2019",
  "2018",
  "2017",
  "2016",
  "2015",
  "2014",
  "2013",
  "2012",
  "2011",
  "2010",
  "2009",
  "2008",
  "2007",
  "2006",
  "2005",
  "2004",
  "2003",
  "2002",
  "2001",
  "2000",
  "1999",
  "1998",
  "1997",
  "1996",
  "1995",
  "1994",
  "1993",
  "1992",
  "1991",
  "1990",
  "1989",
  "1988",
  "1987",
  "1986",
  "1985",
  "1984",
  "1983",
  "1982",
  "1981"
];
const SEASON_MAP = [
  "invierno",
  "primavera",
  "verano",
  "oto\xF1o"
];
const ORDERBY_MAP = ["desc"];

const { first, intersection, isEmpty, join, size, split, compact, map, pickBy, identity } = ___default;
function buildPath(array) {
  if (size(array) === 1)
    return join(array);
  return join(array, "/");
}
function getGenre(value) {
  if (!isEmpty(value)) {
    const result = intersection(GENRE_MAP, [value]);
    return result;
  }
  return [];
}
function getDemography(value) {
  if (!isEmpty(value)) {
    const result = intersection(DEMOGRAPHY_MAP, [value]);
    return result;
  }
  return [];
}
function getCategory(value) {
  if (!isEmpty(value)) {
    const result = intersection(CATEGORY_MAP, [value]);
    return result;
  }
  return [];
}
function getType(value) {
  if (!isEmpty(value)) {
    const result = intersection(TYPES_MAP, [value]);
    return result;
  }
  return [];
}
function getState(value) {
  if (!isEmpty(value)) {
    const result = intersection(STATE_MAP, [value]);
    return result;
  }
  return [];
}
function getYear(value) {
  if (!isEmpty(value)) {
    const result = intersection(YEAR_MAP, [value]);
    return result;
  }
  return [];
}
function getSeason(value) {
  if (!isEmpty(value)) {
    const result = intersection(SEASON_MAP, [value]);
    return result;
  }
  return [];
}
function getOrderBy(value) {
  if (!isEmpty(value)) {
    const result = intersection(ORDERBY_MAP, [value]);
    return result;
  }
  return [];
}
function applyFilter(filter2) {
  const filterFunctions = {
    genre: getGenre,
    demography: getDemography,
    category: getCategory,
    type: getType,
    state: getState,
    year: getYear,
    season: getSeason,
    orderBy: getOrderBy
  };
  const filteredFilter = pickBy(filter2, identity);
  const fullPath = map(filteredFilter, (value, key) => {
    const filterFunction = filterFunctions[key];
    if (filterFunction && value) {
      const result = buildPath(filterFunction(value));
      return result;
    }
  });
  return compact(fullPath).join("/");
}
function extractAnimeInfo($) {
  const animeItems = $(".row .page_directorio");
  const animeInfoList = [];
  animeItems.find(".card").each((index, element) => {
    const $el = $(element);
    const episodes = $el.find(".card-body p").text() ? first(split($el.find(".card-body p").text(), ",")) : null;
    const animeInfo = {
      title: $el.find(".card-title a").attr("title") ?? null,
      slug: split($el.find(".card-title a").attr("href"), "/").filter(Boolean).pop() ?? null,
      image: $el.find(".img-fluid").attr("src") ?? null,
      synopsis: $el.find(".synopsis").text().trim() ?? null,
      type: $el.find("p.card-txt").text().trim() ?? null,
      episodes
    };
    animeInfoList.push(animeInfo);
  });
  return animeInfoList;
}
function extractNextPageLink($) {
  const nextPageLink = $(".text.nav-next").attr("href");
  return nextPageLink ?? null;
}
async function requestFilter({ query }) {
  const allAnimeInfo = [];
  const appliedFilter = applyFilter(query);
  let nextPageLink = `${config.baseURL}directorio/${appliedFilter}`;
  while (nextPageLink) {
    try {
      const response = await makeRequest(nextPageLink, "text", { method: "get" });
      if (!response)
        return null;
      const $ = cheerio__default.load(response);
      allAnimeInfo.push(...extractAnimeInfo($));
      nextPageLink = extractNextPageLink($);
    } catch (error) {
      console.error("[RequestFilter] Error fetching data:", error);
      break;
    }
  }
  return allAnimeInfo;
}
async function filter({ query }) {
  return await requestFilter({ query });
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ToolKit {
}
__publicField(ToolKit, "buildQuery", (obj) => {
  const query = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && obj[key] !== void 0 && obj[key] !== null && obj[key] !== "")
      query[key] = obj[key];
  }
  return qs__default.stringify(query, { encode: false });
});
__publicField(ToolKit, "extractNumberFromString", (inputString) => {
  const match = ___default.parseInt(___default.find(inputString.match(/\d+/), ___default.identity));
  return ___default.isFinite(match) ? match : null;
});

function transformURL(servers) {
  const options = ___default.map(servers, (serverOption) => `https://jkanime.net/c1.php?${ToolKit.buildQuery({ u: serverOption.remote, s: ___default.toLower(serverOption.server) })}`);
  return options;
}
async function getRemoteServerOptions(servers) {
  return transformURL(servers);
}

async function getAnimeServers(animeId, chapter) {
  const requestOpts = {
    path: `${config.baseURL}${animeId}/${chapter}`,
    responseType: "text"
  };
  const responsePromise = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
  if (!responsePromise)
    return null;
  const $ = cheerio__default.load(responsePromise);
  const scriptSrc = $("script").filter((_2, elem) => $(elem).text().includes("var servers")).text().trim();
  const dynamicSrcMatch = scriptSrc.match(/var servers = (\[.*?\]);/s);
  if (!dynamicSrcMatch)
    return null;
  const dynamicSrc = ___default.get(dynamicSrcMatch, "[1]", null);
  if (!dynamicSrc)
    return null;
  const servers = JSON.parse(dynamicSrc);
  const remoteServerOptionsPromise = getRemoteServerOptions(servers);
  const [, remoteServerJsURL] = await Promise.all([responsePromise, remoteServerOptionsPromise]);
  return remoteServerJsURL;
}

const propsToEnglish = {
  tipo: "type",
  genero: "genre",
  studios: "studios",
  demografia: "demography",
  idiomas: "languages",
  episodios: "episodes",
  episodeList: "",
  duracion: "duration",
  emitido: "aired",
  estado: "status",
  calidad: "quality",
  promo: "promo"
};
function buildPromoURL($) {
  const id = $(".animeTrailer").attr("data-yt");
  if (!id)
    return null;
  return `https://youtube.com/watch?${ToolKit.buildQuery({ v: id })}`;
}
async function getExtraInfo(animeSlug) {
  const requestOpts = {
    path: `${config.baseURL}${animeSlug}`,
    responseType: "text"
  };
  const response = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
  if (!response)
    return { extra: null };
  const $ = cheerio__default.load(response);
  const ul = $(".aninfo ul");
  const extra = {};
  ul.find("li").each((_, element) => {
    const span = $(element).find("span").first();
    const key = span.text().trim().replace(":", "").toLowerCase();
    const englishKey = propsToEnglish[key] || key;
    if (key === "genero" || key === "studios" || key === "demografia") {
      const valueList = [];
      $(element).find("a").each((_2, anchor) => {
        valueList.push($(anchor).text().trim());
      });
      extra[englishKey] = valueList;
    } else {
      let value = $(element).text().replace(span.text(), "").trim() ?? null;
      if (/^\d+$/.test(value)) {
        value = Number.parseInt(value, 10);
        extra.episodeList = Array.from({ length: value }, (v, k) => ({
          key: animeSlug,
          value: k + 1
        }));
      }
      extra[englishKey] = value;
    }
    if (key === "estado" && !extra[englishKey])
      extra[englishKey] = span.next().text().trim();
    if (!extra[englishKey])
      extra[englishKey] = null;
  });
  const promoURL = buildPromoURL($);
  extra.promo = promoURL;
  const result = {
    extra
  };
  return result;
}

async function parseAnimeElement$1(element) {
  const $ = cheerio__default.load(element);
  const title = $(".anime__item .anime__item__text h5 a").text().trim() ?? null;
  const slug = ___default.split($(".anime__item a:nth(0)").attr("href"), "/").filter(Boolean).pop() ?? null;
  const image = $(".anime__item .anime__item__pic").attr("data-setbg") ?? null;
  const synopsis = null;
  const episodes = null;
  const type = $(".anime__item__text ul li.anime").text().trim() ?? null;
  const status = $(".anime__item__text ul li").first().text().trim() ?? null;
  return {
    slug,
    title,
    synopsis,
    episodes,
    image,
    type,
    status
  };
}
async function latestAnimeAdded() {
  const requestOpts = {
    path: config.baseURL,
    responseType: "text"
  };
  const response = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
  if (!response)
    return null;
  const $ = cheerio__default.load(response);
  const animeElements = $("div.trending__anime div:nth-child(1)").toArray();
  const animeData = ___default.chain(animeElements).filter((_2, index) => index % 2 !== 0).map(parseAnimeElement$1).thru((promises) => Promise.all(promises)).value().then((response2) => ___default.filter(response2, (anime) => anime.slug !== null));
  return animeData;
}

async function schedule() {
  const requestOpts = {
    path: `${config.baseURL}horario`,
    responseType: "text"
  };
  const daysOfWeek = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
  const scheduleData = await Promise.all(
    ___default.map(daysOfWeek, async (day) => {
      const response = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
      if (!response)
        return { day, animes: [] };
      const $ = cheerio__default.load(response);
      const dayData = {
        day,
        animes: $("div.app-layout div.box.semana").eq(daysOfWeek.indexOf(day)).find("div.cajas div.box").map((index, element) => {
          const $el = $(element);
          return {
            id: $el.find("#guardar-anime").attr("data-anime") ?? null,
            slug: ___default.replace($el.find("h3").parent().attr("href"), /\//g, "") ?? null,
            title: $el.find("h3").text().trim() ?? null,
            image: $el.find("img").attr("src") ?? null,
            lastEpisode: ($el.find(".last span").text().trim().split(":")[1] ?? "").trim() || null,
            timestamp: $el.find(".last time").text().trim() ?? null,
            type: $el.find("#guardar-anime").attr("data-tipo") ?? null
          };
        }).get()
      };
      return dayData;
    })
  );
  return scheduleData;
}

async function search(q) {
  const requestOpts = {
    path: `${config.baseURL}ajax/ajax_search/?${ToolKit.buildQuery({ q })}`,
    responseType: "json"
  };
  const response = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
  if (!response)
    return null;
  return response;
}

const DEFAULT_ACTUAL_SEASON = "Temporada Actual";
async function top(season, year) {
  let requestOpts = {};
  if (season === DEFAULT_ACTUAL_SEASON) {
    requestOpts = {
      path: `${config.baseURL}top`,
      responseType: "text"
    };
  } else {
    requestOpts = {
      path: `${config.baseURL}top?${ToolKit.buildQuery({ temporada: season, fecha: year })}`,
      responseType: "text"
    };
  }
  const response = await makeRequest(requestOpts.path, requestOpts.responseType, { method: "get" });
  if (!response)
    return null;
  const $ = cheerio__default.load(response);
  const animeElements = $("div.list").toArray();
  const animePromises = ___default.map(animeElements, parseAnimeElement);
  const animeData = await Promise.all(animePromises);
  return animeData;
}
async function parseAnimeElement(element) {
  const $ = cheerio__default.load(element);
  const id = null;
  const title = $("h2.portada-title a").attr("title") ?? null;
  const slug = ___default.split($("h2.portada-title a").attr("href"), "/").filter(Boolean).pop() ?? null;
  const image = $(".timg img").attr("src") ?? null;
  const synopsis = $("div#animinfo p").text().trim() ?? null;
  const type = $("span.title").text() ? ___default.trim(___default.first(___default.split($("span.title").text(), "/"))) : null;
  const episodes = ToolKit.extractNumberFromString($("span.title").text()) ?? null;
  return {
    id,
    slug,
    title,
    synopsis,
    episodes,
    image,
    type
  };
}

const index = {
  byAlphabet,
  filter,
  getAnimeServers,
  getExtraInfo,
  latestAnimeAdded,
  schedule,
  search,
  top
};

module.exports = index;
